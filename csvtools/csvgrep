#!/usr/bin/python
#
# A filter on CSV that is similar to SELECT * FROM CSV WHERE... in SQL.
#
# Igor Konnov

import argparse
import csv
import re
from sys import stdout
import sys

class ArgError(BaseException):
    def __init__(self, msg):
        BaseException.__init__(self, msg)

class DataError(BaseException):
    def __init__(self, msg):
        BaseException.__init__(self, msg)


EQ = "EQ"
RE = "RE"
AND = "AND"
OR = "OR"
NOT = "NOT"
class Expr:
    def __init__(self, kind, ops):
        self.kind = kind
        self.ops = ops


# XXX: a simple recursive parser, I don't have time to think about it
class Parser:
    def __init__(self, args):
        self.args = args
        self.buf = args

    def parse(self):
        expr = self.parse_and()
        if not self.is_eof():
            raise ArgError("Expected end, found: " + " ".join(self.buf))
        return expr

    def parse_and(self):
        ops = [self.parse_or()]
        while self.top() == "-a":
            self.consume("-a")
            ops.append(self.parse_or())

        if len(ops) > 1:
            return Expr(AND, ops)
        else:
            return ops[0]

    def parse_or(self):
        ops = [self.parse_not()]
        while self.top() == "-o":
            self.consume("-o")
            ops.append(self.parse_not())

        if len(ops) > 1:
            return Expr(OR, ops)
        else:
            return ops[0]

    def parse_not(self):
        neg = False
        while self.top() == "!":
            self.consume("!")
            neg = not neg

        expr = self.parse_eq_re()
        if neg:
            return Expr(NOT, [expr])
        else:
            return expr

    def parse_eq_re(self):
        tok = self.get()
        if tok.find("~=") != -1:
            i = tok.find("~=")
            k, r = tok[: i], re.compile(tok[i + 2 :])
            return Expr(RE, [k, r])
        elif tok.find('=') != -1:
            i = tok.find('=')
            k, v = tok[: i], tok[i + 1 :]
            return Expr(EQ, [k, v])
        else:
            raise ArgError("Expected k=v or k~=re, found %s" % tok)

    def is_eof(self):
        return self.buf == []

    def top(self):
        if self.buf == []:
            return None
        else:
            return self.buf[0]

    def get(self):
        if self.buf == []:
            raise ArgError("No arguments")
        tok = self.buf[0]
        self.buf = self.buf[1:]
        return tok

    def put(self, tok):
        self.buf = [tok] + self.buf

    def consume(self, expected):
        if self.buf[0] <> expected:
            raise ArgError("Expected %s, found %s" % (expected, self.buf[0]))
        else:
            self.buf = self.buf[1:]


def use():
    print "Use: %s k1=v1 -a k2~=v2 -o k3=v3 <csv" % sys.argv[0]
    print ""
    sys.exit(1)


def parse():
    if len(sys.argv) < 2:
        use()

    try:
        expr = Parser(sys.argv[1:]).parse()
    except ArgError, e:
        print "Error: " + str(e)
        use()

    return expr


def row_matches(expr, row):
    if expr.kind == AND:
        for op in expr.ops:
            if not row_matches(op, row):
                return False

        return True
    elif expr.kind == OR:
        for op in expr.ops:
            if row_matches(op, row):
                return True

        return False
    elif expr.kind == NOT:
        return not row_matches(expr.ops[0], row)
    elif expr.kind == EQ:
        name, val = expr.ops
        try:
            return row[name] == val
        except KeyError:
            raise DataError("Column %s not found" % name)
    elif expr.kind == RE:
        name, rexp = expr.ops
        try:
            return rexp.match(row[name])
        except KeyError:
            raise DataError("Column %s not found" % name)


def filter_csv(expr, infile):
    def escape(s):
        if s.find(",") != -1:
            return '"%s"' % s
        else:
            return s

    reader = csv.reader(infile, delimiter=',', quotechar='"')
    fields = None                                                               
    for row_arr in reader:
        if not fields:
            fields = row_arr # the first row is the header
            print ",".join(fields)
        else:
            row = {}
            for i, k in enumerate(fields):
                row[k] = row_arr[i]
            
            try:
                if row_matches(expr, row):
                    print ",".join([escape(r) for r in row_arr])
            except DataError, e:
                print >>sys.stderr, "%s in: %s" % (str(e), r)


if __name__ == "__main__":
    expr = parse()
    filter_csv(expr, sys.stdin)


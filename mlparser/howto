In case you want to play with the tool, do the following:

# building
cd theta/tools/mlparser
./make.sh

# the automatic CEGAR loop

./cegar ../../promela/bcast_symb.pml ../../promela/univ_relay.never

# follow the messages by the script...

# if you want to provide an invariant, then introduce one like tx_inv
# in bcast_symb.
# Then check, it is actually an invariant:
OCAMLRUNPARAM=b ./run.native -i tx_inv ../../promela/bcast_symb.pml

# then add assume(tx_inv) in the beginning of the atomic section
# and at the end of it before the local variables are reset (see bcast_symb.pml)
#
# after that run cegar once more:
./cegar ../../promela/bcast_symb.pml ../../promela/univ_relay.never

# the manual execution of the tool chain

OCAMLRUNPARAM=b ./run.native -a ../../promela/bcast_symb.pml
view original.prm     # the original system as parsed by the tool
view abs-interval.prm # the interval abstraction
view abs-counter.prm  # the counter abstraction
spin -a -N ../../promela/univ_unforg.never abs-counter.prm
gcc -o pan pan.c && ./pan -a -m1000000
# see a counter example produced in Spin
spin -t -N ../../promela/univ_unforg.never abs-counter.prm | grep '{' >spin.trace

# properties we want to check
promela/univ_{unforg,corr,relay}.never

# see a counter example in VASS and (perhaps) refine the system:

OCAMLRUNPARAM=b ./run.native -t spin.trace ../../promela/bcast_symb.pml
